#!/usr/bin/env python

print('Import Python modules. If one is missing get it with',
      '"sudo apt-get install python-..."')

from gi.repository import Gtk, Gdk, AppIndicator3, Notify, Keybinder

import time
import threading
import platform
import os
import json
import sys
import argparse


#resources_dir = os.getcwd()
resources_dir = os.path.abspath(os.path.dirname(sys.argv[0]))
script_name = os.path.basename(sys.argv[0])

PREFERENCES_FILENAME = os.path.join(resources_dir, "prefs.json")


class Status():
    """Pomodoro Status. Takes 4 possible values:
      - STOP, the pomodoro timer is not running
      - RUN, the pomodoro timer is up and running
      - BREAK, short break (3-5min)
      - PAUSE, long break (15-30min)
    """

    def __init__(self, notification_icon):
        "Initializes the pomodoro status"

        self.current_status = Status.STOP
        self.pomodoro_stage = 0
        self.indicator = notification_icon
        self.notifications = Notifications()

    def next(self):
        "Sets and returns the next status"

        if (self.current_status == Status.RUN):
            if (self.pomodoro_stage == 4):
                self.current_status = Status.PAUSE
                self.pomodoro_stage = 0
            else:
                self.current_status = Status.BREAK
        else:
            self.current_status = Status.RUN
            self.pomodoro_stage += 1

        self.notify()
        return self.current_status

    def stop(self):
        "Stops the pomodoro and resets the pomodoro count to 0"

        self.current_status = Status.STOP
        #we reset and start again. If a Pomodoro Begins, It Has to Ring
        self.pomodoro_stage = 0
        self.notify()

    def isRunning(self):
        "Returns current status"
        return self.current_status

    def getStage(self):
        "Returns current stage"
        return self.pomodoro_stage

    def notify(self):
        "Plays a notification sound"

        soundfile = resources_dir + "/audio/"
        iconfile = resources_dir + "/images/"
        if (self.current_status == self.STOP):
            soundfile += "stop.wav"
            iconfile += "flag-blue.png"
            self.notifications.stop()
        elif (self.current_status == self.RUN):
            soundfile += "run.wav"
            iconfile += "flag-red.png"
            self.notifications.run()
        elif (self.current_status == self.BREAK):
            soundfile += "break.wav"
            iconfile += "flag-yellow.png"
            self.notifications.rest()
        elif (self.current_status == self.PAUSE):
            soundfile += "pause.wav"
            iconfile += "flag-green.png"
            self.notifications.pause()

        self.indicator.set_icon(iconfile)
        self.indicator.set_attention_icon(iconfile)

        if platform.system() == "Windows":
            from winsound import PlaySound, SND_FILENAME, SND_ASYNC
            PlaySound(soundfile, SND_FILENAME | SND_ASYNC)
        elif (platform.system() == "Linux"):
            from wave import open as waveOpen
            from ossaudiodev import open as ossOpen
            s = waveOpen(soundfile, 'rb')
            (nc, sw, fr, nf, comptype, compname) = s.getparams()
            dsp = ossOpen('/dev/dsp', 'w')
            try:
                from ossaudiodev import AFMT_S16_NE
            except ImportError:
                if byteorder == "little":
                    AFMT_S16_NE = ossaudiodev.AFMT_S16_LE
                else:
                    AFMT_S16_NE = ossaudiodev.AFMT_S16_BE
            dsp.setparameters(AFMT_S16_NE, nc, fr)
            data = s.readframes(nf)
            s.close()
            dsp.write(data)
            dsp.close()

    def getMinutes(self):
        "Returns current status minutes"

        prefs = Preferences()
        if (self.current_status == self.STOP):
            return 0  # minutes
        elif (self.current_status == self.RUN):
            return prefs.get_work_time()
        elif (self.current_status == self.BREAK):
            return prefs.get_short_break_time()
        elif (self.current_status == self.PAUSE):
            return prefs.get_long_break_time()

    STOP = 0
    RUN = 1
    BREAK = 2
    PAUSE = 3


class Timer:
    "Pomodoro timer"

    def __init__(self, status):
        "Initializes thread"
        self.thread = self.CountingThread(status)
        self.thread.event.clear()
        self.thread.start()

    def isRunning(self):
        "Returns thread's status"
        return self.thread.status.isRunning()

    def stop(self):
        "Pauses the thread and resets the pomodoro"
        self.thread.event.clear()  # pause thread
        self.thread.stop()  # reset pomodoro

    def start(self):
        "Start a new pomodoro, set time and run the thread"
        self.thread.status.next()
        self.thread.minutes = self.thread.status.getMinutes()
        self.thread.seconds = 0
        self.thread.event.set()  # run thread

    class CountingThread(threading.Thread):
        "CountingThread"

        def __init__(self, status):
            "Stops the pomodoro"
            threading.Thread.__init__(self)
            self.status = status
            self.daemon = True
            self.event = threading.Event()
            # mins and secs must be 0 so the run method can switch status
            self.minutes, self.seconds = 0, 0
            self.observers = []

        def notify_observers(self):
            for obs in self.observers:
                obs.update(self.minutes, self.seconds)

        def stop(self):
            "Stops the pomodoro"
            self.status.stop()

        def run(self):
            "Runs thread"
            while(True):
                self.event.wait()
                if not self.status.isRunning():
                    continue
                if not (self.minutes == 0 and self.seconds == 0):
                    time.sleep(1)
                    if self.seconds == 0:
                        self.minutes, self.seconds = self.minutes - 1, 59
                    else:
                        self.seconds -= 1
                # Start new pomodoro, break or pause
                else:
                    self.status.next()
                    self.minutes, self.seconds = self.status.getMinutes(), 0

                self.notify_observers()


class TimeLabel(Gtk.Label):
    "Gtk.Label observer. It's automatically updated by the thread"

    def __init__(self, thread):
        "Initializes label to 00:00 and registers itself in thread"
        Gtk.Label.__init__(self, label="00:00")
        thread.observers.append(self)
        self.thread = thread

    def update(self, mins, secs):
        "Update label with new minutes and seconds"
        self.set_text("{:0>2}:{:0>2}".format(mins, secs))


class Preferences():
    "Preferences handler"

    def __init__(self):
        "Initializes preferences and load work time from file"

        self.KEY_WORK_TIME = "WT"
        self.KEY_LONG_BREAK_TIME = "LT"
        self.KEY_SHORT_BREAK_TIME = "ST"
        self.KEY_START_STOP_KEYBIND = "SSK"
        self.KEY_SHOW_TIME_KEYBIND = "STK"
        self.DEFAULT_WORK_TIME = 25
        self.DEFAULT_LONG_BREAK_TIME = 15
        self.DEFAULT_SHORT_BREAK_TIME = 5
        self.DEFAULT_START_STOP_KEYBIND = "<Ctrl><Alt>P"
        self.DEFAULT_SHOW_TIME_KEYBIND = "<Ctrl><Alt>space"
        self.SAVED_WORK_TIME = 0
        self.SAVED_LONG_BREAK_TIME = 0
        self.SAVED_SHORT_BREAK_TIME = 0
        self.SAVED_START_STOP_KEYBIND = ""
        self.SAVED_SHOW_TIME_KEYBIND = ""
        self.read_work_time()

    def save_preferences(self, work_time, short_break_time, long_break_time,
                         start_stop_keybind, show_time_keybind):
        "Save preferences"

        keybinds.instance.unbind()

        obj = {self.KEY_WORK_TIME: work_time,
               self.KEY_SHORT_BREAK_TIME: short_break_time,
               self.KEY_LONG_BREAK_TIME: long_break_time,
               self.KEY_START_STOP_KEYBIND: start_stop_keybind,
               self.KEY_SHOW_TIME_KEYBIND: show_time_keybind}
        dump = json.dumps(obj)
        file = open(PREFERENCES_FILENAME, "w")
        file.write(dump)
        file.close()

        self.read_work_time()
        keybinds.preferences = self
        keybinds.instance.bind()

    def read_work_time(self):
        "Read work time from file"

        try:
            file = open(PREFERENCES_FILENAME, "r")
            dump = json.loads(file.read())
            file.close()
            self.SAVED_WORK_TIME = dump[self.KEY_WORK_TIME]
            self.SAVED_LONG_BREAK_TIME = dump[self.KEY_LONG_BREAK_TIME]
            self.SAVED_SHORT_BREAK_TIME = dump[self.KEY_SHORT_BREAK_TIME]
            self.SAVED_START_STOP_KEYBIND = dump[self.KEY_START_STOP_KEYBIND]
            self.SAVED_SHOW_TIME_KEYBIND = dump[self.KEY_SHOW_TIME_KEYBIND]
        except IOError:
            self.SAVED_WORK_TIME = self.DEFAULT_WORK_TIME
            self.SAVED_LONG_BREAK_TIME = self.DEFAULT_LONG_BREAK_TIME
            self.SAVED_SHORT_BREAK_TIME = self.DEFAULT_SHORT_BREAK_TIME
            self.SAVED_START_STOP_KEYBIND = self.DEFAULT_START_STOP_KEYBIND
            self.SAVED_SHOW_TIME_KEYBIND = self.DEFAULT_SHOW_TIME_KEYBIND

    def get_work_time(self):
        "Get saved work time"
        return self.SAVED_WORK_TIME

    def get_long_break_time(self):
        "Get saved long break time"
        return self.SAVED_LONG_BREAK_TIME

    def get_short_break_time(self):
        "Get short break time"
        return self.SAVED_SHORT_BREAK_TIME

    def get_start_stop_keybind(self):
        "Get start/stop keybind"
        return self.SAVED_START_STOP_KEYBIND

    def get_show_time_keybind(self):
        "Get show time keybind"
        return self.SAVED_SHOW_TIME_KEYBIND


class OptionsWindow(Gtk.Window):
    "Options window"

    def __init__(self):
        "Create window"

        Gtk.Window.__init__(self)
        self.set_title("Pumubuntu")  # TODO: Set an icon for this window...
        self.prefs = Preferences()
        self.main_box = Gtk.VBox()
        self.box1 = Gtk.HBox()
        self.label1 = Gtk.Label(label="Work time (in minutes):")
        self.entry1 = Gtk.Entry()
        self.entry1.set_text(str(self.prefs.get_work_time()))
        self.box1.add(self.label1)
        self.box1.add(self.entry1)
        self.main_box.add(self.box1)
        self.box2 = Gtk.HBox()
        self.label2 = Gtk.Label(label="Short break time (in minutes):")
        self.entry2 = Gtk.Entry()
        self.entry2.set_text(str(self.prefs.get_short_break_time()))
        self.box2.add(self.label2)
        self.box2.add(self.entry2)
        self.main_box.add(self.box2)
        self.box3 = Gtk.HBox()
        self.label3 = Gtk.Label(label="Long break time (in minutes):")
        self.entry3 = Gtk.Entry()
        self.entry3.set_text(str(self.prefs.get_long_break_time()))
        self.box3.add(self.label3)
        self.box3.add(self.entry3)
        self.main_box.add(self.box3)
        self.box4 = Gtk.HBox()
        self.label4 = Gtk.Label(label="Start/Stop hotkey:")
        self.entry4 = Gtk.Entry()
        self.entry4.set_text(str(self.prefs.get_start_stop_keybind()))
        self.box4.add(self.label4)
        self.box4.add(self.entry4)
        self.main_box.add(self.box4)
        self.box5 = Gtk.HBox()
        self.label5 = Gtk.Label(label="Show time hotkey:")
        self.entry5 = Gtk.Entry()
        self.entry5.set_text(str(self.prefs.get_show_time_keybind()))
        self.box5.add(self.label5)
        self.box5.add(self.entry5)
        self.main_box.add(self.box5)
        self.box6 = Gtk.HBox()
        self.button1 = Gtk.Button.new_from_stock(Gtk.STOCK_SAVE)
        self.button1.connect("clicked", self.options_event, "save")
        self.button2 = Gtk.Button.new_from_stock(Gtk.STOCK_QUIT)
        self.button2.connect("clicked", self.options_event, "quit")
        self.box6.add(self.button1)
        self.box6.add(self.button2)
        self.main_box.add(self.box6)  # TODO: Add a restore values buttom...
        self.add(self.main_box)

    def options_event(self, button, event):
        "Window's events"

        if(event == "save"):
            if(self.entry1.get_text() != "" and self.entry2.get_text() != ""
                    and self.entry3.get_text() != ""
                    and self.entry4.get_text() != ""):
                try:
                    values = map(int, [self.entry1.get_text(),
                                       self.entry2.get_text(),
                                       self.entry3.get_text()])
                    values.append(self.entry4.get_text())
                    values.append(self.entry5.get_text())
                    self.prefs.save_preferences(values[0], values[1],
                                                values[2], values[3],
                                                values[4])
                    self.destroy()
                except ValueError:
                    dialog = Gtk.MessageDialog(None, Gtk.DIALOG_MODAL,
                                               Gtk.MESSAGE_INFO,
                                               Gtk.BUTTONS_NONE,
                                               "Please, just use entire "
                                               "numbers.")
                    dialog.add_button(Gtk.STOCK_CLOSE, Gtk.RESPONSE_CLOSE)
                    dialog.run()
                    dialog.destroy()
        if(event == "quit"):
            self.destroy()


class Notifications(object):
    "Notifications handler"

    def __init__(self):
        "Initializes notification handler and creates notifications"

        Notify.init("pumubuntu")
        self._run = Notify.Notification.new("Here we go!",
                                            "Time to get to work!", None)
        self._run.set_timeout(1)
        self._stop = Notify.Notification.new("Interrupted!",
                                             "The pomodoro has been stopped!",
                                             None)
        self._stop.set_timeout(1)
        self._rest = Notify.Notification.new("Break!",
                                             "Good job! You earned a break!",
                                             None)
        self._rest.set_timeout(1)
        self._pause = Notify.Notification.new("Long break!",
                                              "Good job! You earned a long "
                                              "break!",
                                              None)
        self._pause.set_timeout(1)
        self._show = Notify.Notification.new("","",None)
        self._show.set_timeout(1)

    def run(self):
        "Show running notification"
        self._run.show()

    def stop(self):
        "Shows stop notification"
        self._stop.show()

    def rest(self):
        "Shows rest notification"
        self._rest.show()

    def pause(self):
        "Shows pause notification"
        self._pause.show()

    def show(self, time):
        "Shows blank notification"
        self._show.update(time)
        self._show.show()


class Keybinds(object):
    "Keybind handler"

    def __init__(self, menu_event, preferences):
        "Initializes menu event and preferences"
        Keybinder.init()
        self.menu_event = menu_event
        self.preferences = preferences
        self.instance = self

    def bind(self):
        "Add new keybinds"

        keystr1 = self.preferences.get_start_stop_keybind()
        Keybinder.bind(keystr1, self.menu_event, "play_pause")
        keystr2 = self.preferences.get_show_time_keybind()
        Keybinder.bind(keystr2, self.menu_event, "show_time")

    def unbind(self):
        "Remove keybinds"

        keystr1 = self.preferences.get_start_stop_keybind()
        Keybinder.unbind(keystr1)
        keystr2 = self.preferences.get_show_time_keybind()
        Keybinder.unbind(keystr2)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(prog='pumubuntu')
    parser.add_argument('--nopadsp', action="store_true", dest='nopadsp',
                        help='Don\'t try to fix Ubuntu sound using padsp')
    options = parser.parse_args()

    # Ubuntu fix for hearing sound...
    if(platform.system() == "Linux"):
        (distname, ver, id) = platform.linux_distribution()
        if(distname == "Ubuntu" and (not options.nopadsp)):
            # restart ourselves using padsp
            os.system("padsp "+resources_dir + "/" + script_name +
                      " --nopadsp &")
            exit()

    if not(Notify.init("Pumubuntu")):
        print("[!] Error: Could not load Notify...")
        exit()

    Gdk.threads_init()
    # Set an app indicator in system tray...
    ind = AppIndicator3.Indicator.new("Pumubuntu",
                                      resources_dir + "/images/flag-blue.png",
                                      AppIndicator3.IndicatorCategory.
                                      APPLICATION_STATUS)
    ind.set_status(AppIndicator3.IndicatorStatus.ACTIVE)
    ind.set_attention_icon(resources_dir + "/images/flag-blue.png")

    status = Status(ind)  # we use this here and there

    def menu_event(menu_item, event):
        if(event == "play_pause"):
            if (timer.isRunning()):
                timer.stop()
            else:
                timer.start()
        elif(event == "exit"):
            Gtk.main_quit()
        elif(event == "options"):
            OptionsWindow().show_all()
        elif(event == "show_time"):
            label = "{:0>2}:{:0>2}".format(timer.thread.minutes,
                    timer.thread.seconds)
            status.notifications.show(label)

    keybinds = Keybinds(menu_event, Preferences())
    keybinds.bind()

    timer = Timer(status)

    # Indicator menu...
    menu = Gtk.Menu()
    label_time = TimeLabel(timer.thread)
    menu_item = Gtk.MenuItem()
    menu_item.add(label_time)
    menu_item.connect("activate", menu_event, "play_pause")
    menu_item.show()
    menu.append(menu_item)

    menu_item = Gtk.ImageMenuItem.new_from_stock(Gtk.STOCK_PREFERENCES, None)
    menu_item.connect("activate", menu_event, "options")
    menu_item.show()
    menu.append(menu_item)

    menu_item = Gtk.ImageMenuItem.new_from_stock(Gtk.STOCK_QUIT, None)
    menu_item.connect("activate", menu_event, "exit")
    menu_item.show()
    menu.append(menu_item)

    ind.set_menu(menu)

    try:
        Gtk.main()
    except KeyboardInterrupt:
        print("")
    exit()
